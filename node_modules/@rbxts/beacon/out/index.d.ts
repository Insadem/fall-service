/// <reference types="@rbxts/compiler-types" />
/// <reference types="@rbxts/compiler-types" />
export type SignalParams<T> = Parameters<T extends unknown[] ? (...args: T) => never : T extends unknown ? (arg: T) => never : () => never>;
export type SignalCallback<T> = (...args: SignalParams<T>) => unknown;
export type SignalWait<T> = T extends unknown[] ? LuaTuple<T> : T;
/**
 * Represents a connection to a signal.
 */
export declare class Connection<T> {
    private signal;
    /**
     * Whether or not the connection is connected.
     * @readonly
     */
    Connected: boolean;
    /**
     * @hidden
     */
    _next?: Connection<T>;
    /**
     * @hidden
     */
    _fn: SignalCallback<T>;
    constructor(signal: Signal<T>, /** @hidden */ fn: SignalCallback<T>);
    /**
     * Disconnects the connection.
     */
    Disconnect(): void;
    /**
     * Alias for `Disconnect`.
     */
    Destroy(): void;
}
/**
 * Signals allow events to be dispatched to any number of listeners.
 */
export declare class Signal<T extends unknown[] | unknown> {
    private waitingThreads;
    /**
     * @hidden
     */
    _handlerListHead?: Connection<T>;
    /**
     * Connects a callback. This callback will be fired when the signal
     * is fired and will receive the arguments passed through firing.
     * @param callback `SignalCallback<T>`
     * @returns `Connection<T>`
     */
    Connect(callback: SignalCallback<T>): Connection<T>;
    /**
     * Connects a callback, which will be disconnected after the next time
     * the signal is fired.
     * @param callback `SignalCallback<T>`
     * @returns `Connection<T>`
     */
    Once(callback: SignalCallback<T>): Connection<T>;
    /**
     * Fires the signal. The passed arguments will be sent along to all
     * connected callbacks. Callbacks are invoked using `task.spawn`
     * internally.
     * @param args
     */
    Fire(...args: SignalParams<T>): void;
    /**
     * Fires the signal. The passed arguments will be sent along to all
     * connected callbacks. Callbacks are invoked using `task.defer`
     * internally.
     * @param args
     */
    FireDeferred(...args: SignalParams<T>): void;
    /**
     * Yields the current thread until the next time the signal is fired.
     * The arguments from firing are returned.
     * @yields
     * @returns `SignalWait<T>`
     */
    Wait(): SignalWait<T>;
    /**
     * Disconnects all connections on the signal.
     */
    DisconnectAll(): void;
    /**
     * Alias for `DisconnectAll`.
     */
    Destroy(): void;
}
